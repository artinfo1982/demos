/*
* 拷贝构造函数使用传入对象的值生成一个新的对象实例，而赋值运算符是将对象的值赋值给一个已经存在的实例。
* 调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符。
* 
* 浅拷贝：类中没有指针和动态分配内存时，拷贝类的所有成员函数只是简单的值赋值，源对象不影响目标对象。
* 深拷贝：类中存在指针，如果浅拷贝，则源对象和目标对象的两个指针都指向同一块内存地址，当源或者目标对象析构时，会释放一次指针地址，当另一个对象析构时，就会重复释放同一个地址，程序崩溃。
* 
* 原则一：如果确定一个类需要有析构函数，建议给它添加自定义的拷贝构造函数和赋值运算符。
* 原则二：自定义的拷贝构造函数和赋值运算符总是成对出现的。
*/

#include <iostream>

class A
{
  public:
    A(std::string name) : n(name) { std::cout << n << ", normal constructor" << std::endl; }
    // 默认情况下，编译器会自动的隐式生成一个拷贝构造函数和赋值运算符
    // 用户可以使用delete来指定不生成拷贝构造函数和赋值运算符，这样对象就不能通过值传递，也不能进行赋值运算
    A(const A &) = delete;
    A &operator=(const A &) = delete;
    ~A() {}

  private:
    std::string n;
};

class B
{
  public:
    B(std::string name) : n(name) { std::cout << n << ", normal constructor" << std::endl; }
    B(const B &b) : n(b.n) { std::cout << n << ", copy constructor" << std::endl; }
    B &operator=(const B &)
    {
        std::cout << n << ", assign" << std::endl;
        return *this;
    }
    ~B() {}

  private:
    std::string n;
};

void f1(B b) {}

void f2(B &) {}

B f3()
{
    B b("b"); // 函数体内生成一个新的临时局部对象
    return b; // return的时候，将这个临时对象直接返回
}

class C
{
  public:
    C(int size) : _size(size)
    {
        data = new int[_size];
    }
    C(const C &c) : _size(c._size)
    {
        data = new int[_size]; // 存在指针等动态内存分配操作时，必须采用深拷贝，拷贝构造函数必须重新创建内存分配
    }
    C &operator=(const C &)
    {
        data = new int[_size]; // 存在指针等动态内存分配操作时，必须采用深拷贝，赋值运算符必须重新创建内存分配
    }
    ~C()
    {
        delete[] data;
    }

  private:
    int _size;
    int *data;
};

int main()
{
    A a1("a1");
    /*
    * A a2 = a1; // 错误，无论是拷贝构造函数还是赋值运算符，都是已经delete的，无法被调用
    */
    std::cout << "----------------------------------------------" << std::endl;

    B b1("b1");
    B b2 = b1; // 虽然用=，但实际是用一个对象生成另一个对象，因此调用拷贝构造函数
    std::cout << "----------------------------------------------" << std::endl;

    B b3("b3");
    b3 = b1; // b1、b3已经存在，将b1的值赋给b3，调用赋值运算符
    std::cout << "----------------------------------------------" << std::endl;

    f1(b1); // 对象传值给形参，形参拷贝生成的对象，调用拷贝构造函数
    std::cout << "----------------------------------------------" << std::endl;

    f2(b1); // 对象传引用给形参，并没有生成新对象，也没有赋值，什么都不调用
    std::cout << "----------------------------------------------" << std::endl;

    b3 = f3(); // 函数体内生成临时对象，调用普通构造函数，赋给一个已经存在的对象，调用赋值运算符
    std::cout << "----------------------------------------------" << std::endl;

    B b4 = f3(); // 函数体内生成新对象，调用普通构造函数，赋值对象本不存在，什么都不调用
    std::cout << "----------------------------------------------" << std::endl;

    C c1(3);
    C c2 = c1;

    return 0;
}